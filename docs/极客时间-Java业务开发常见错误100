https://github.com/JosephZhu1983/java-common-mistakes



# 1.使用了并发工具类库，线程安全就高枕无忧了吗

1.ThreadLocal内存泄漏，原因是tomcat线程复用，快速复现可以通过设置tomcat核心线程数为1，解决方案在finally代码块中显式清除threadlocal中的数据

2.ConcurrentHashMap只能保证提供的原子性读写操作是线程安全的，对于如putAll这样的聚合操作仍是线程不安全的，在多线程环境下需要加锁

3.利用ConcurrentHashMap的computeIfAbsent（底层为CAS）来做符合逻辑操作，这虽然不是原子性操作，但是是线程安全的，配合LongAdder可以用于多线程环境下的计数器

4.CopyOnWriteArrayList虽然是线程安全的ArrayList，但是其实现方式是：每次修改数据时都会复制一份数据出来，这样读数据时不需要加锁，并保证数据最终一致性，所以有明显的适用场景即读多写少，或者强调无锁读的场景，在大量写的场景时会严重影响性能



# 2.代码加锁：不要让“锁”事成为烦心事

1.在业务代码中加锁，除了考虑锁的粒度，还可以从以下角度优化：

- 对于读写比例差异明细的场景，考虑使用ReentrantReadWriteLock细化区分读写锁
- 考虑使用StampedLock的乐观锁特性
- 不要轻易开启公平锁特性，会影响性能

2.业务逻辑中有多把锁时要考虑死锁问题，通常的规避方案是避免无限等待（如设置等待时间上限）和循环等待（如给获取锁排序）



# 3.线程池：业务代码最常用也最容易犯错的组件

1.线程池的声明需要手动进行，newFixedThreadPool的工作队列使用了一个无界队列，在任务较多且执行慢的情况下，队列会快速挤压，导致OOM；而newCachedThreadPool会无限制的创建工作线程，同样会导致OOM



2.线程池默认的工作行为：

- 不会初始化corePoolSize个线程，而是有任务来了才创建工作线程
- 当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中
- 当工作队列满了后扩容线程池，直到线程个数达到maximumPoolSize
- 如果队列已满并已达到最大线程数后还有任务进来，按照拒绝策略处理
- 当线程数大于核心线程数时，线程等待keepAliveTime后还是没有任务需要处理的话，收缩线程到核心线程数

也可以通过一些手段来改变这些默认行为 如：

- 声明线程池后立即调用prestartAllCoreThreads方法来启动所有核心线程
- 传入true给allowCoreThreadTimeOut方法，让核心线程同样在空闲时间被回收

线程池总是先用工作队列来存放来不及处理的任务，满了之后再扩容线程数，当工作队列设置的很大时，最大线程数这个参数基本不起作用，因为队列很难满，或者满了再去扩容已经于事无补，但是把工作队列设置的很小时，可能又很容易触发拒绝策略



可以改造线程池来实现：优先开启更多的线程，而把队列当做后备方案

大致思路：

- 由于线程池在工作队列满了的情况下无法入队，会扩容线程池，那么可以重写队列的offer方法，造成这个队列已满的假象
- 由于重写了这一方法，在达到最大线程数线程池会触发拒绝策略，所以需要自定义一个拒绝策略，这个时候再把任务真正插入队列

**tomcat中就有类似的实现**



3.明确线程池是否需要复用，还是每次业务逻辑开始，就开启一个线程池，这种方式是较为不合理的，通常情况下线程池都是复用的



4.复用线程池不代表始终使用同一个线程池，可以根据任务的性质来选用不同的线程池，IO密集型任务和CPU计算密集型任务的偏好是不同的

- 对于IO密集任务，可以考虑更多的线程数，而不需要太大的队列
- 对于CPU密集任务，线程数量不宜过多，可以设置为CPU核心数量左右的线程数量，需要较长的队列来做缓冲

如果希望减少任务间的互相干扰，考虑按需使用隔离的线程池



5.监控线程池是非常重要的



# 4.连接池：别让连接池帮了倒忙

1.鉴别客户端SDK是否基于连接池，如果SDK没有使用连接池，而是直接使用TCP连接，首先会有较大的开销，其次因为TCP基于字节流，在多线程环境下若对同一连接进行复用，可能会产生线程安全问题

- 连接池和连接分离的API：通过一个XXXPool获得XXXConnection
- 内部带有连接池的API：对外提供一个XXXClient类，这个类内部维护了线程池，使用时无需考虑连接的获取和归还
- 非连接池的API：一般命名为XXXConnection，每次使用需要创建和断开连接，且通常是线程不安全的，使用时可以考虑自己封装一个线程池



2.多线程使用Jedis时，如果复用Jedis对象，其实是复用底层的RedisOutPutStream来写入命令，无法保证整条命令以一个原子操作写入Socket，也无法确保写入、读取前没有其他数据写到远端，应该通过Jedis提供的线程安全的类JedisPool来获取Jedis实例，JedisPool可以声明为static在多个线程之间共享，扮演连接池的角色，使用时通过try-with-resources从JedisPool获取和归还Jedis实例。



3.程序退出时，可以通过shutdownhook在程序退出之前关闭连接池资源

![image-20210326101550520](极客时间-Java业务开发常见错误100.assets/image-20210326101550520.png)



4.使用池时，一定要复用池，否则其使用代价会比每次创建单一对象更大，复用方式可以把XXXClient声明为static，只创建一次，并且在JVM关闭前通过addShutDownHook钩子关闭连接池



5.在Spring中可以把XXXClient资源定义为Bean，通过@PostConstruct和@PreDestory来加载和释放资源



6.合理配置连接池参数



# 05.HTTP调用：你考虑到超时、重试、并发了吗？

1.网络请求需要考虑的三点：

- 框架设置的默认超时是否合理
- 考虑到网络的不稳定，可以在超时后进行重试，但是需要考虑接口的幂等性设计
- 考虑框架是否会想浏览器一样限制并发连接数，以免在高并发情况下HTTP调用的并发限制成为瓶颈







