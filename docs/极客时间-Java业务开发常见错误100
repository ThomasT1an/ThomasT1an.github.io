https://github.com/JosephZhu1983/java-common-mistakes



# 1.使用了并发工具类库，线程安全就高枕无忧了吗

1.ThreadLocal内存泄漏，原因是tomcat线程复用，快速复现可以通过设置tomcat核心线程数为1，解决方案在finally代码块中显式清除threadlocal中的数据

2.ConcurrentHashMap只能保证提供的原子性读写操作是线程安全的，对于如putAll这样的聚合操作仍是线程不安全的，在多线程环境下需要加锁

3.利用ConcurrentHashMap的computeIfAbsent（底层为CAS）来做符合逻辑操作，这虽然不是原子性操作，但是是线程安全的，配合LongAdder可以用于多线程环境下的计数器

4.CopyOnWriteArrayList虽然是线程安全的ArrayList，但是其实现方式是：每次修改数据时都会复制一份数据出来，这样读数据时不需要加锁，并保证数据最终一致性，所以有明显的适用场景即读多写少，或者强调无锁读的场景，在大量写的场景时会严重影响性能



# 2.代码加锁：不要让“锁”事成为烦心事

1.在业务代码中加锁，除了考虑锁的粒度，还可以从以下角度优化：

- 对于读写比例差异明细的场景，考虑使用ReentrantReadWriteLock细化区分读写锁
- 考虑使用StampedLock的乐观锁特性
- 不要轻易开启公平锁特性，会影响性能

2.业务逻辑中有多把锁时要考虑死锁问题，通常的规避方案是避免无限等待（如设置等待时间上限）和循环等待（如给获取锁排序）



# 3.线程池：业务代码最常用也最容易犯错的组件

1.线程池的声明需要手动进行，newFixedThreadPool的工作队列使用了一个无界队列，在任务较多且执行慢的情况下，队列会快速挤压，导致OOM；而newCachedThreadPool会无限制的创建工作线程，同样会导致OOM



2.线程池默认的工作行为：

- 不会初始化corePoolSize个线程，而是有任务来了才创建工作线程
- 当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中
- 当工作队列满了后扩容线程池，直到线程个数达到maximumPoolSize
- 如果队列已满并已达到最大线程数后还有任务进来，按照拒绝策略处理
- 当线程数大于核心线程数时，线程等待keepAliveTime后还是没有任务需要处理的话，收缩线程到核心线程数

也可以通过一些手段来改变这些默认行为 如：

- 声明线程池后立即调用prestartAllCoreThreads方法来启动所有核心线程
- 传入true给allowCoreThreadTimeOut方法，让核心线程同样在空闲时间被回收

线程池总是先用工作队列来存放来不及处理的任务，满了之后再扩容线程数，当工作队列设置的很大时，最大线程数这个参数基本不起作用，因为队列很难满，或者满了再去扩容已经于事无补，但是把工作队列设置的很小时，可能又很容易触发拒绝策略



可以改造线程池来实现：优先开启更多的线程，而把队列当做后备方案

大致思路：

- 由于线程池在工作队列满了的情况下无法入队，会扩容线程池，那么可以重写队列的offer方法，造成这个队列已满的假象
- 由于重写了这一方法，在达到最大线程数线程池会触发拒绝策略，所以需要自定义一个拒绝策略，这个时候再把任务真正插入队列

**tomcat中就有类似的实现**



3.明确线程池是否需要复用，还是每次业务逻辑开始，就开启一个线程池，这种方式是较为不合理的，通常情况下线程池都是复用的



4.复用线程池不代表始终使用同一个线程池，可以根据任务的性质来选用不同的线程池，IO密集型任务和CPU计算密集型任务的偏好是不同的

- 对于IO密集任务，可以考虑更多的线程数，而不需要太大的队列
- 对于CPU密集任务，线程数量不宜过多，可以设置为CPU核心数量左右的线程数量，需要较长的队列来做缓冲

如果希望减少任务间的互相干扰，考虑按需使用隔离的线程池



5.监控线程池是非常重要的



# 4.连接池：别让连接池帮了倒忙







