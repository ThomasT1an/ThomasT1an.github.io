https://github.com/JosephZhu1983/java-common-mistakes



# 1.使用了并发工具类库，线程安全就高枕无忧了吗

1.ThreadLocal内存泄漏，原因是tomcat线程复用，快速复现可以通过设置tomcat核心线程数为1，解决方案在finally代码块中显式清除threadlocal中的数据

2.ConcurrentHashMap只能保证提供的原子性读写操作是线程安全的，对于如putAll这样的聚合操作仍是线程不安全的，在多线程环境下需要加锁

3.利用ConcurrentHashMap的computeIfAbsent（底层为CAS）来做符合逻辑操作，这虽然不是原子性操作，但是是线程安全的，配合LongAdder可以用于多线程环境下的计数器

4.CopyOnWriteArrayList虽然是线程安全的ArrayList，但是其实现方式是：每次修改数据时都会复制一份数据出来，这样读数据时不需要加锁，并保证数据最终一致性，所以有明显的适用场景即读多写少，或者强调无锁读的场景，在大量写的场景时会严重影响性能



# 2.代码加锁：不要让“锁”事成为烦心事

1.在业务代码中加锁，除了考虑锁的粒度，还可以从以下角度优化：

- 对于读写比例差异明细的场景，考虑使用ReentrantReadWriteLock细化区分读写锁
- 考虑使用StampedLock的乐观锁特性
- 不要轻易开启公平锁特性，会影响性能

2.业务逻辑中有多把锁时要考虑死锁问题，通常的规避方案是避免无限等待（如设置等待时间上限）和循环等待（如给获取锁排序）



# 3.线程池：业务代码最常用也最容易犯错的组件

1.线程池的声明需要手动进行，newFixedThreadPool的工作队列使用了一个无界队列，在任务较多且执行慢的情况下，队列会快速挤压，导致OOM；而newCachedThreadPool会无限制的创建工作线程，同样会导致OOM



2.线程池默认的工作行为：

- 不会初始化corePoolSize个线程，而是有任务来了才创建工作线程
- 当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中
- 当工作队列满了后扩容线程池，直到线程个数达到maximumPoolSize
- 如果队列已满并已达到最大线程数后还有任务进来，按照拒绝策略处理
- 当线程数大于核心线程数时，线程等待keepAliveTime后还是没有任务需要处理的话，收缩线程到核心线程数



