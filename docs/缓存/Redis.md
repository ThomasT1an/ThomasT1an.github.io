# Redis线程模型

是单线程的 指的是整个文件事件处理器是单线程的

## 文件事件处理器 

redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

- 多个 socket
- IO 多路复用程序及其队列
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。

![image-20210111082057618](Redis.assets/image-20210111082057618.png)

客户端发送set请求后，会尝试读取命令回复，所以会有readable和writable两个事件入队

当一个socket同时可读写的时候，服务器会先处理读后处理写



## IO多路复用简单描述

IO复用模型的思路是使用一个单独的线程去处理多个socket fd，这个线程对fd进行管理，由它来对它所管理的fd进行监控，当有数据准备好时，再分配对应的线程去读取数据。

此时socket应该采用非阻塞模式

这样在整个过程中只有socket调用select/poll/epoll这些函数的时候会阻塞，收发消息是不会阻塞的



这个所谓的监控线程有多种实现：

select是最常见的也是性能最低的 只能监听1024个描述符 采用轮询的方式对每一个描述符询问是否可用

poll和select区别不大 没有最大连接数的限制 原因是它基于链表

epoll采用了事件通知机制的思想，当描述符就绪，内核会callback来激活这个fd（但是其实内部是有一个等待队列和一个就绪队列的，激活是将fd放入就绪队列，对就绪队列中的处理仍然需要轮询，这样避免了对所有fd的轮询）





## IO多路复用实现

通过包装常见的select/epoll(linux)/kqueue(freeBSD/macOS)这些IO多路复用的函数库来实现

Redis为这些库实现了相同的API，所以IO多路复用的底层是可以互换的

程序会在编译时根据系统环境选择性能最高的IO多路复用函数库作为底层实现

evport->epoll->kqueue->select

 evport不常见 在Solaris 10系统上



# 过期时间

通过一个过期字典来保存数据库中所有键的过期时间

key为指针 指向键空间的某个键对象

value为long long的过期时间

Redis 使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键

执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。
执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。
当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。
当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。
从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。
当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知





# 持久化

## RDB

RDB会生成一个经过压缩的二进制文件，保存某个时间点上的数据库状态（非空数据库以及它们的键值对）

通过两个指令可以生成RDB文件 一个是SAVE 一个是BGSAVE

SAVE会阻塞Redis服务器进程，在RDB文件创建完毕之前，Redis无法对外提供服务

BGSAVE会派生出一个子进程，由子进程负责创建RDB文件，父进程（服务器进程）继续处理命令请求



BGSAVE为什么可以不阻塞？

子进程刚产生时，和父进程共享内存中的代码段和数据段，这是linux的机制，所以子进程可以对这些数据进行遍历并写入磁盘，此时父进程会继续提高服务，那么内存中的数据就会被修改，这个时候会使用操作系统的COW机制（Copy On Write）进行数据段页面的分离，

数据段是有很多个**内存页**组合而成，当父进程某一些数据进行修改时，数据必定在某一个页上，此时会将这一页复制一份分离出来，然后对这个复制的页面进行修改，子进程仍按照原页去写RDB

随着父进程修改的数据越来越多，被复制的页也越来越多，但是始终不会超过原内存大小的2倍

另一点是Redis实例里冷数据的比例往往较高，短暂的RDB过程中几乎不会有多少页被复制

子进程是按照自己被派生出来的那一瞬间的数据进行序列化写磁盘的



什么时候进行RDB？

可以通过设置指令，若服务器在N秒内对数据库进行了M次修改，则会执行BGSAVE

Redis内部会有计数器来统计修改了多少次数据库，并会周期性检查是否满足条件



## AOF

