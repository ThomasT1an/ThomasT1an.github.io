# 1.链表

1.哑节点：

用一个新建的虚拟头指向头结点

ListNode preHead = new ListNode(-1)

preHead.next = head;

结果返回preHead.next 

哑结点不参与运算 可以避免一些特殊判断



2.双指针

链表题目的基本解法



2.1快慢指针 特殊的双指针

一个指针走一步 一个指针走两步

可以用来取链表中点 可以用来判断链表是否成环



一个指针先走k步 另一个指针再开始走

可以用来取链表的倒数的第几个节点



3.避免成环

对节点的next进行修改后，要留意是否需要把该节点的前置节点的next断开 否则会导致成环



4.缓存

把联表存入线性表/map中 然后可以进行排序/取前置节点等操作

然而实际上考察联表的题是不希望使用这种偷懒的操作的

不过有的情况下的递归做法也会有O(n)的空间复杂度



5.删除节点

通常来说要删除某个节点需要从头遍历找到该节点的前驱

但是如果入参不是head而是要删除的节点cur

那么可以直接让cur.next覆盖cur 也就是完全复制cur.next的val和next到cur上

然后断开cur.next的next（不断也行）



| 题目分类         | 题目编号            |
| ---------------- | ------------------- |
| 链表的删除       | 203E、237E、19M     |
| 链表的遍历       | 430X 深度优先       |
| 链表的旋转与反转 | 61、24、206、92、25 |
| 链表的高精度加法 | 2、445              |
| 链表的合并       | 21、23              |

